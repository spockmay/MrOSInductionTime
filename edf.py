import pyedflib     # http://pyedflib.readthedocs.io/en/latest/

from datetime import datetime, timedelta

def signalname_to_dict(signalNames):
    res = {}
    index = 0
    for i in signalNames:
        res[i.lower()] = index
        index += 1
    return res


class EDF:
    """ EDF class docstring!
    Loads the EDF file specified by filename into the instance.  If filename is not given, creates an empty instance
    and .load must be called at some point in the future.
    Args:
        filename: Properly escaped filename of the EDF file to load. Default is None
    """
    f = None
    dur_sec = None
    channels = None

    def __init__(self, filename=None):
        if filename:
            self.f = pyedflib.EdfReader(filename)
            self.channels = signalname_to_dict(self.f.getSignalLabels())
            self.dur_sec = self.f.getFileDuration()

    def load(self, filename):
        """Load an EDF file into the instance.
        Loads the specified EDF file into the instance. This file is stored internally as 'f' but should generally by
        accessed via the available member functions.
        Args:
            filename: Properly escaped filename of the EDF file to load.
        """

        self.__init__(filename)

    def getOverview(self):
        """Prints a silly overview of the file.
        Not useful to run, but ok to help understand what is _in_ the loaded file"""

        assert self.f is not None, "EDF not yet loaded..."

        print("edfsignals: %i" % self.f.signals_in_file)
        print("file duration: %i seconds" % self.f.file_duration)
        print("startdate: %i-%i-%i" % (self.f.getStartdatetime().day, self.f.getStartdatetime().month, self.f.getStartdatetime().year))
        print("starttime: %i:%02i:%02i" % (
            self.f.getStartdatetime().hour, self.f.getStartdatetime().minute, self.f.getStartdatetime().second))
        # print("patient: %s" % f.getP);
        # print("recording: %s" % f.getPatientAdditional())
        print("patientcode: %s" % self.f.getPatientCode())
        print("gender: %s" % self.f.getGender())
        print("birthdate: %s" % self.f.getBirthdate())
        print("patient_name: %s" % self.f.getPatientName())
        print("patient_additional: %s" % self.f.getPatientAdditional())
        print("admincode: %s" % self.f.getAdmincode())
        print("technician: %s" % self.f.getTechnician())
        print("equipment: %s" % self.f.getEquipment())
        print("recording_additional: %s" % self.f.getRecordingAdditional())
        print("datarecord duration: %f seconds" % self.f.getFileDuration())
        print("number of datarecords in the file: %i" % self.f.datarecords_in_file)
        print("number of annotations in the file: %i" % self.f.annotations_in_file)

    def get_start_time(self):
        return datetime(year=self.f.getStartdatetime().year,
                        month=self.f.getStartdatetime().month,
                        day=self.f.getStartdatetime().day,
                        hour=self.f.getStartdatetime().hour,
                        minute=self.f.getStartdatetime().minute,
                        second=self.f.getStartdatetime().second)

    def extractChannel(self,channelName):
        """Extract a single channel of data from the edf file.
        Extracts all data in the channelName channel from the edf file and the associated sample rate to a dictionary.
        Args:
            channelName: string with the name of the channel to load. Name is case insensitive.
        Returns:
            A dictionary with two keys. 'signal' Numpy N-dimensional array with ndim=1 and typically long lengths, and
            'sample_rate' frequency (Hz) of the recorded signal since each signal can be recorded at different rates.
        """

        assert self.f is not None, "EDF not yet loaded..."

        channelName = channelName.lower()
        assert channelName in self.channels, "Channel Name is not in this EDF"
        c = self.channels[channelName]  # get the ID number of the channel

        r = {'signal': self.f.readSignal(c)}
        r['sample_rate'] = r['signal'].size / float(self.dur_sec)

        return r

    def getHeaderSize(self, filename):
        """Gets the size of the EDF file's header
        There's really no reason to use this other than cleanHeader()"""

        with open(filename, 'rb') as f:
            head = f.read(252)
            num_signals = int(f.read(4).rstrip())
            header_size = (num_signals + 1) * 256
        return header_size

    def cleanHeader(self, filename):
        """Cleans the EDF file's header of non-standard ASCII characters.
         The EDF files generated by a 1985 study had characters in the header that are non-standard ASCII. This method
         will scan through the header and replace all offending characters with a space. Note that this EDITS the file,
         so make sure to preserve a copy of the original somewhere!!"""

        header_size = self.getHeaderSize(filename)

        with open(filename, 'r+b') as f:
            header = f.read(header_size)

            new_head = ''
            for char in header:
                if ord(char) > 127:
                    new_head += ' '
                else:
                    new_head += char

            if header == new_head:
                print "No changes necessary to EDF header"
                return

            f.seek(0)
            f.write(new_head)
        return

    def channel_to_tuples(self, channelName, ts=None):
        if not isinstance(ts, datetime):
            ts = self.get_start_time()

        a = self.extractChannel(channelName)
        dt_sec = 1.0/a['sample_rate']
        data = a['signal']

        out = []
        i = 0
        for v in data:
            out.append( (ts+timedelta(seconds=i*dt_sec), v) )
            i += 1
        return out

